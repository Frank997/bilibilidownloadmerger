方法1：遍历一次目录，遍历一次文件名集合，逻辑清晰，容易理解，性能可能稍差
思路：遍历一次目录，取出所有video.m4s(或audio.m4s)的完整路径，添加进集合，然后遍历此集合，对每一个条目执行如下操作：根据video.m4s绝对路径取出audio.m4s路径(简单把路径末尾的video.m4s换成audio.m4s即可)，然后通过 video.m4s的上级目录/entry.json，定位包含视频名的文件，接着再从此文件中取出视频名，最后调用 merge(video.m4s, audio.m4s, videoName) 进行合并即可。
<br>
<br>
方法2：只遍历一次目录，在遍历时进行合并，性能可能略好，但不如方法1逻辑清晰
//以下写给自己看的伪代码
var needMerge = true  // merging when first time found audio.m4s or video.m4s, but dont merge when sencond time found audio.m4s or video.m4s, because already merged, then revert this flag for next video merging
for f in rootDir {
    find(f)
}


func merge(audio,video,fileName) {
    ffmpeg merge
}

getFileName(entry.json) {
    open entry.json
    get title with str matcing '"title:"'
    remove illegal str in title
    return title
}

func find(f) {
    if(f is dir){
        find(f)
    }else {
        if(f is audio.m4s) {
            if(needMerge){
              fileName = getFileName(fParentDir/entry.json)
              merge(f, fParentDir/video.m4s,fileName)
            }
            needMerge = !needMerge
        }else if f is video.m4s {
            if(needMerge){
             getFileName(fParentDir/entry.json)
             merge(f, fParentDir/video.m4s,fileName)
            }
            needMerge = !needMerge
            
        }
    }
}
